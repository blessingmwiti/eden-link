{"ast":null,"code":"import { BehaviorSubject, interval } from 'rxjs';\nimport * as i0 from \"@angular/core\";\nexport class SensorDataService {\n  constructor() {\n    this.MAX_DATA_POINTS = 20;\n    this.sensorData = new BehaviorSubject([]);\n    this.lastValues = {\n      temperature: 23,\n      humidity: 65,\n      light: 3000\n    };\n    // Initialize with one data point\n    this.addNewDataPoint();\n    // Update data every 3 seconds\n    interval(3000).subscribe(() => {\n      this.addNewDataPoint();\n    });\n  }\n  addNewDataPoint() {\n    const currentData = this.sensorData.value;\n    const newData = {\n      timestamp: new Date(),\n      temperature: this.generateNextValue('temperature', 18, 28, 0.5),\n      humidity: this.generateNextValue('humidity', 55, 75, 1),\n      light: this.generateNextValue('light', 2000, 6000, 100)\n    };\n    // Add new data point and keep only the last MAX_DATA_POINTS\n    const updatedData = [...currentData, newData].slice(-this.MAX_DATA_POINTS);\n    this.sensorData.next(updatedData);\n  }\n  generateNextValue(sensor, min, max, maxChange) {\n    // Generate a random change within maxChange\n    const change = (Math.random() * 2 - 1) * maxChange;\n    // Calculate new value\n    let newValue = this.lastValues[sensor] + change;\n    // Ensure value stays within bounds\n    newValue = Math.max(min, Math.min(max, newValue));\n    // Update last value\n    this.lastValues[sensor] = newValue;\n    return +newValue.toFixed(1);\n  }\n  getSensorData() {\n    return this.sensorData.asObservable();\n  }\n  static {\n    this.ɵfac = function SensorDataService_Factory(t) {\n      return new (t || SensorDataService)();\n    };\n  }\n  static {\n    this.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n      token: SensorDataService,\n      factory: SensorDataService.ɵfac,\n      providedIn: 'root'\n    });\n  }\n}","map":{"version":3,"names":["BehaviorSubject","interval","SensorDataService","constructor","MAX_DATA_POINTS","sensorData","lastValues","temperature","humidity","light","addNewDataPoint","subscribe","currentData","value","newData","timestamp","Date","generateNextValue","updatedData","slice","next","sensor","min","max","maxChange","change","Math","random","newValue","toFixed","getSensorData","asObservable","factory","ɵfac","providedIn"],"sources":["/home/injinia/eden-link/src/app/services/sensor-data.service.ts"],"sourcesContent":["import { Injectable } from '@angular/core';\nimport { BehaviorSubject, Observable, interval } from 'rxjs';\nimport { map } from 'rxjs/operators';\n\nexport interface SensorData {\n  timestamp: Date;\n  temperature: number;\n  humidity: number;\n  light: number;\n}\n\n@Injectable({\n  providedIn: 'root'\n})\nexport class SensorDataService {\n  private readonly MAX_DATA_POINTS = 20;\n  private sensorData = new BehaviorSubject<SensorData[]>([]);\n  private lastValues = {\n    temperature: 23,\n    humidity: 65,\n    light: 3000\n  };\n\n  constructor() {\n    // Initialize with one data point\n    this.addNewDataPoint();\n\n    // Update data every 3 seconds\n    interval(3000).subscribe(() => {\n      this.addNewDataPoint();\n    });\n  }\n\n  private addNewDataPoint() {\n    const currentData = this.sensorData.value;\n    const newData = {\n      timestamp: new Date(),\n      temperature: this.generateNextValue('temperature', 18, 28, 0.5),\n      humidity: this.generateNextValue('humidity', 55, 75, 1),\n      light: this.generateNextValue('light', 2000, 6000, 100)\n    };\n\n    // Add new data point and keep only the last MAX_DATA_POINTS\n    const updatedData = [...currentData, newData]\n      .slice(-this.MAX_DATA_POINTS);\n    \n    this.sensorData.next(updatedData);\n  }\n\n  private generateNextValue(\n    sensor: keyof typeof this.lastValues,\n    min: number,\n    max: number,\n    maxChange: number\n  ): number {\n    // Generate a random change within maxChange\n    const change = (Math.random() * 2 - 1) * maxChange;\n    \n    // Calculate new value\n    let newValue = this.lastValues[sensor] + change;\n    \n    // Ensure value stays within bounds\n    newValue = Math.max(min, Math.min(max, newValue));\n    \n    // Update last value\n    this.lastValues[sensor] = newValue;\n    \n    return +newValue.toFixed(1);\n  }\n\n  getSensorData(): Observable<SensorData[]> {\n    return this.sensorData.asObservable();\n  }\n} "],"mappings":"AACA,SAASA,eAAe,EAAcC,QAAQ,QAAQ,MAAM;;AAa5D,OAAM,MAAOC,iBAAiB;EAS5BC,YAAA;IARiB,KAAAC,eAAe,GAAG,EAAE;IAC7B,KAAAC,UAAU,GAAG,IAAIL,eAAe,CAAe,EAAE,CAAC;IAClD,KAAAM,UAAU,GAAG;MACnBC,WAAW,EAAE,EAAE;MACfC,QAAQ,EAAE,EAAE;MACZC,KAAK,EAAE;KACR;IAGC;IACA,IAAI,CAACC,eAAe,EAAE;IAEtB;IACAT,QAAQ,CAAC,IAAI,CAAC,CAACU,SAAS,CAAC,MAAK;MAC5B,IAAI,CAACD,eAAe,EAAE;IACxB,CAAC,CAAC;EACJ;EAEQA,eAAeA,CAAA;IACrB,MAAME,WAAW,GAAG,IAAI,CAACP,UAAU,CAACQ,KAAK;IACzC,MAAMC,OAAO,GAAG;MACdC,SAAS,EAAE,IAAIC,IAAI,EAAE;MACrBT,WAAW,EAAE,IAAI,CAACU,iBAAiB,CAAC,aAAa,EAAE,EAAE,EAAE,EAAE,EAAE,GAAG,CAAC;MAC/DT,QAAQ,EAAE,IAAI,CAACS,iBAAiB,CAAC,UAAU,EAAE,EAAE,EAAE,EAAE,EAAE,CAAC,CAAC;MACvDR,KAAK,EAAE,IAAI,CAACQ,iBAAiB,CAAC,OAAO,EAAE,IAAI,EAAE,IAAI,EAAE,GAAG;KACvD;IAED;IACA,MAAMC,WAAW,GAAG,CAAC,GAAGN,WAAW,EAAEE,OAAO,CAAC,CAC1CK,KAAK,CAAC,CAAC,IAAI,CAACf,eAAe,CAAC;IAE/B,IAAI,CAACC,UAAU,CAACe,IAAI,CAACF,WAAW,CAAC;EACnC;EAEQD,iBAAiBA,CACvBI,MAAoC,EACpCC,GAAW,EACXC,GAAW,EACXC,SAAiB;IAEjB;IACA,MAAMC,MAAM,GAAG,CAACC,IAAI,CAACC,MAAM,EAAE,GAAG,CAAC,GAAG,CAAC,IAAIH,SAAS;IAElD;IACA,IAAII,QAAQ,GAAG,IAAI,CAACtB,UAAU,CAACe,MAAM,CAAC,GAAGI,MAAM;IAE/C;IACAG,QAAQ,GAAGF,IAAI,CAACH,GAAG,CAACD,GAAG,EAAEI,IAAI,CAACJ,GAAG,CAACC,GAAG,EAAEK,QAAQ,CAAC,CAAC;IAEjD;IACA,IAAI,CAACtB,UAAU,CAACe,MAAM,CAAC,GAAGO,QAAQ;IAElC,OAAO,CAACA,QAAQ,CAACC,OAAO,CAAC,CAAC,CAAC;EAC7B;EAEAC,aAAaA,CAAA;IACX,OAAO,IAAI,CAACzB,UAAU,CAAC0B,YAAY,EAAE;EACvC;;;uBA1DW7B,iBAAiB;IAAA;EAAA;;;aAAjBA,iBAAiB;MAAA8B,OAAA,EAAjB9B,iBAAiB,CAAA+B,IAAA;MAAAC,UAAA,EAFhB;IAAM;EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}