{"ast":null,"code":"/*!\n* chartjs-plugin-annotation v2.1.2\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2023 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, defined, callback, isObject, valueOrDefault, toRadians, toFont, isArray, addRoundedRectPath, toTRBLCorners, isFinite, toPadding, toDegrees, PI, drawPoint, RAD_PER_DEG, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(state, event) {\n      return filterElements(state, event, {\n        intersect: true\n      });\n    },\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(state, event, options) {\n      return getNearestItem(state, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'x'\n      });\n    },\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(state, event, options) {\n      return filterElements(state, event, {\n        intersect: options.intersect,\n        axis: 'y'\n      });\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {Object} state - the state of the plugin\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(state, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(state, event, options);\n}\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {\n      x: event.x,\n      y: center.y\n    };\n  } else if (axis === 'y') {\n    return {\n      x: center.x,\n      y: event.y\n    };\n  }\n  return center;\n}\nfunction filterElements(state, event, options) {\n  return state.visibleElements.filter(element => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\nfunction getNearestItem(state, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n  return filterElements(state, event, options).reduce((nearestItems, element) => {\n    const center = element.getCenterPoint();\n    const evenPoint = getPointByAxis(event, center, options.axis);\n    const distance = distanceBetweenPoints(event, evenPoint);\n    if (distance < minDistance) {\n      nearestItems = [element];\n      minDistance = distance;\n    } else if (distance === minDistance) {\n      // Can have multiple items at the same distance in which case we sort by size\n      nearestItems.push(element);\n    }\n    return nearestItems;\n  }, []).sort((a, b) => a._index - b._index).slice(0, 1); // return only the top item;\n}\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst hooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = false;\n  state.moveListened = false;\n  state._getElements = getElements; // for testing\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    } else if (defined(state.listeners[hook])) {\n      delete state.listeners[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && typeof scope.click === 'function') {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n      case 'mousemove':\n      case 'mouseout':\n        return handleMoveEvents(state, event, options);\n      case 'click':\n        return handleClickEvents(state, event, options);\n    }\n  }\n}\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n  let elements;\n  if (event.type === 'mousemove') {\n    elements = getElements(state, event, options.interaction);\n  } else {\n    elements = [];\n  }\n  const previous = state.hovered;\n  state.hovered = elements;\n  const context = {\n    state,\n    event\n  };\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\nfunction dispatchMoveEvents({\n  state,\n  event\n}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\nconst isOlderPart = (act, req) => req > act || act.length > req.length && act.slice(0, req.length) === req;\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} borderWidth\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  const hBorderWidth = borderWidth / 2;\n  return Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2) <= Math.pow(radius + hBorderWidth, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {number} borderWidth\n * @returns {boolean}\n */\nfunction inBoxRange(point, {\n  x,\n  y,\n  x2,\n  y2\n}, axis, borderWidth) {\n  const hBorderWidth = borderWidth / 2;\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {\n    centerX,\n    centerY\n  } = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {\n    x: centerX,\n    y: centerY\n  };\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\nconst isPercentString = s => typeof s === 'string' && s.endsWith('%');\nconst toPercent = s => clamp(parseFloat(s) / 100, 0, 1);\n\n/**\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @param {number} to\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {number} to\n * @returns {number}\n */\nfunction getSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {\n    x,\n    width\n  } = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value) {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, 'center'),\n      y: valueOrDefault(value.y, 'center')\n    };\n  }\n  value = valueOrDefault(value, 'center');\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\nconst widthCache = new Map();\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]';\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, {\n  x,\n  y\n}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n  const font = toFont(options.font);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + font.string + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    ctx.save();\n    ctx.font = font.string;\n    const count = lines.length;\n    let width = 0;\n    for (let i = 0; i < count; i++) {\n      const text = lines[i];\n      width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    }\n    ctx.restore();\n    const height = count * font.lineHeight + strokeWidth;\n    widthCache.set(mapKey, {\n      width,\n      height\n    });\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {\n    x,\n    y,\n    width,\n    height\n  } = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x,\n    y,\n    w: width,\n    h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n */\nfunction drawLabel(ctx, rect, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const font = toFont(options.font);\n  const lh = font.lineHeight;\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + lh / 2 + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.font = font.string;\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    labels.forEach((l, i) => ctx.strokeText(l, x, y + i * lh));\n  }\n  ctx.fillStyle = options.color;\n  labels.forEach((l, i) => ctx.fillText(l, x, y + i * lh));\n  ctx.restore();\n}\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter(scale => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {\n    chartArea,\n    scales\n  } = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {\n    x,\n    y\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  if (!xScale && !yScale) {\n    return {};\n  }\n  let {\n    left: x,\n    right: x2\n  } = xScale || chart.chartArea;\n  let {\n    top: y,\n    bottom: y2\n  } = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {\n    min: options.xMin,\n    max: options.xMax,\n    start: x,\n    end: x2\n  });\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {\n    min: options.yMin,\n    max: options.yMax,\n    start: y2,\n    end: y\n  });\n  y = yDim.start;\n  y2 = yDim.end;\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    return {\n      x: box.x + options.xAdjust,\n      y: box.y + options.yAdjust,\n      x2: box.x + size + options.xAdjust,\n      y2: box.y + size + options.yAdjust,\n      centerX: box.centerX + options.xAdjust,\n      centerY: box.centerY + options.yAdjust,\n      width: size,\n      height: size\n    };\n  }\n  return getChartCircle(chart, options);\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  const {\n    x,\n    y\n  } = properties;\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options)\n  }];\n  properties.initProperties = {\n    x,\n    y\n  };\n  return properties;\n}\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    width: size,\n    height: size\n  };\n}\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\nfunction calculateX({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    x: start,\n    x2: end,\n    width: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.x,\n    padding: {\n      start: padding.left,\n      end: padding.right\n    },\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\nfunction calculateY({\n  properties,\n  options\n}, labelSize, position, padding) {\n  const {\n    y: start,\n    y2: end,\n    height: size\n  } = properties;\n  return calculatePosition$1({\n    start,\n    end,\n    size,\n    borderWidth: options.borderWidth\n  }, {\n    position: position.y,\n    padding: {\n      start: padding.top,\n      end: padding.bottom\n    },\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  const {\n    start,\n    end,\n    borderWidth\n  } = boxOpts;\n  const {\n    position,\n    padding: {\n      start: padStart,\n      end: padEnd\n    },\n    adjust\n  } = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const y = calculateY({\n    properties,\n    options\n  }, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\nclass BoxAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nBoxAnnotation.id = 'boxAnnotation';\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nconst positions = ['left', 'bottom', 'top', 'right'];\nclass LabelAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y\n    } = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\n    return inBoxRange({\n      x,\n      y\n    }, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {\n        centerX,\n        centerY\n      } = resolveBoxProperties(chart, options);\n      point = {\n        x: centerX,\n        y: centerY\n      };\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureRect(point, labelSize, options, padding);\n    return {\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\nLabelAnnotation.id = 'labelAnnotation';\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%'\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction measureRect(point, size, options, padding) {\n  const width = size.width + padding.width + options.borderWidth;\n  const height = size.height + padding.height + options.borderWidth;\n  const position = toPosition(options.position);\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\nfunction calculatePosition(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\nfunction drawCallout(ctx, element) {\n  const {\n    pointX,\n    pointY,\n    options\n  } = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {\n    separatorStart,\n    separatorEnd\n  } = getCalloutSeparatorCoord(element, calloutPosition);\n  const {\n    sideStart,\n    sideEnd\n  } = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({\n    x: pointX,\n    y: pointY\n  }, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\nfunction getCalloutSeparatorCoord(element, position) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {\n      x: x + adjust,\n      y\n    };\n    separatorEnd = {\n      x: separatorStart.x,\n      y: y2\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {\n      x,\n      y: y + adjust\n    };\n    separatorEnd = {\n      x: x2,\n      y: separatorStart.y\n    };\n  }\n  return {\n    separatorStart,\n    separatorEnd\n  };\n}\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {\n    width,\n    height,\n    options\n  } = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {\n    y,\n    width,\n    height,\n    options\n  } = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {\n      x: separatorStart.x,\n      y: y + getSize(height, start)\n    };\n    sideEnd = {\n      x: sideStart.x + side,\n      y: sideStart.y\n    };\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {\n      x: separatorStart.x + getSize(width, start),\n      y: separatorStart.y\n    };\n    sideEnd = {\n      x: sideStart.x,\n      y: sideStart.y + side\n    };\n  }\n  return {\n    sideStart,\n    sideEnd\n  };\n}\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\nfunction resolveCalloutAutoPosition(element, options) {\n  const {\n    x,\n    y,\n    x2,\n    y2,\n    width,\n    height,\n    pointX,\n    pointY,\n    centerX,\n    centerY,\n    rotation\n  } = element;\n  const center = {\n    x: centerX,\n    y: centerY\n  };\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({\n      x: xPoints[index],\n      y: yPoints[index]\n    }, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {\n        x: pointX,\n        y: pointY\n      })\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\nfunction getLabelSize({\n  x,\n  y,\n  width,\n  height,\n  options\n}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\nfunction isPointInRange(element, callout, position) {\n  const {\n    pointX,\n    pointY\n  } = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\nconst pointInLine = (p1, p2, t) => ({\n  x: p1.x + t * (p2.x - p1.x),\n  y: p1.y + t * (p2.y - p1.y)\n});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {\n  x,\n  y,\n  x2,\n  y2\n}, axis) => axis === 'y' ? {\n  start: Math.min(y, y2),\n  end: Math.max(y, y2),\n  value: mouseY\n} : {\n  start: Math.min(x, x2),\n  end: Math.max(x, x2),\n  value: mouseX\n};\nclass LineAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hBorderWidth = this.options.borderWidth / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const epsilon = sqr(hBorderWidth);\n      const point = {\n        mouseX,\n        mouseY\n      };\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    const limit = rangeLimit(mouseX, mouseY, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth || isOnLabel(this, {\n      mouseX,\n      mouseY\n    }, useFinalPosition, axis);\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      options\n    } = this;\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    const {\n      startOpts,\n      endOpts,\n      startAdjust,\n      endAdjust\n    } = getArrowHeads(this);\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    const {\n      scales,\n      chartArea\n    } = chart;\n    const scale = scales[options.scaleID];\n    const area = {\n      x: chartArea.left,\n      y: chartArea.top,\n      x2: chartArea.right,\n      y2: chartArea.bottom\n    };\n    let min, max;\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        area.x = min;\n        area.x2 = max;\n      } else {\n        area.y = min;\n        area.y2 = max;\n      }\n    } else {\n      const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n      const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n      if (xScale) {\n        applyScaleValueToDimension(area, xScale, {\n          min: options.xMin,\n          max: options.xMax,\n          start: xScale.left,\n          end: xScale.right,\n          startProp: 'x',\n          endProp: 'x2'\n        });\n      }\n      if (yScale) {\n        applyScaleValueToDimension(area, yScale, {\n          min: options.yMin,\n          max: options.yMax,\n          start: yScale.bottom,\n          end: yScale.top,\n          startProp: 'y',\n          endProp: 'y2'\n        });\n      }\n    }\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside ? limitLineToArea({\n      x,\n      y\n    }, {\n      x: x2,\n      y: y2\n    }, chart.chartArea) : {\n      x,\n      y,\n      x2,\n      y2,\n      width: Math.abs(x2 - x),\n      height: Math.abs(y2 - y)\n    };\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties\n    }];\n    return properties;\n  }\n}\nLineAnnotation.id = 'lineAnnotation';\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  display: true,\n  endValue: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\nfunction isLineInArea({\n  x,\n  y,\n  x2,\n  y2\n}, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  return !(x < left && x2 < left || x > right && x2 > right || y < top && y2 < top || y > bottom && y2 > bottom);\n}\nfunction limitPointToArea({\n  x,\n  y\n}, p2, {\n  top,\n  right,\n  bottom,\n  left\n}) {\n  if (x < left) {\n    y = interpolateY(left, {\n      x,\n      y\n    }, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {\n      x,\n      y\n    }, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {\n      x,\n      y\n    }, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {\n      x,\n      y\n    }, p2);\n    y = bottom;\n  }\n  return {\n    x,\n    y\n  };\n}\nfunction limitLineToArea(p1, p2, area) {\n  const {\n    x,\n    y\n  } = limitPointToArea(p1, p2, area);\n  const {\n    x: x2,\n    y: y2\n  } = limitPointToArea(p2, p1, area);\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: Math.abs(x2 - x),\n    height: Math.abs(y2 - y)\n  };\n}\nfunction intersects(element, {\n  mouseX,\n  mouseY\n}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {\n    x: x1,\n    y: y1,\n    x2,\n    y2\n  } = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return sqr(mouseX - xx) + sqr(mouseY - yy) <= epsilon;\n}\nfunction isOnLabel(element, {\n  mouseX,\n  mouseY\n}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\nfunction applyScaleValueToDimension(area, scale, options) {\n  const dim = getDimensionByScale(scale, options);\n  area[options.startProp] = dim.start;\n  area[options.endProp] = dim.end;\n}\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {\n    width,\n    height,\n    padding\n  }, chart.chartArea);\n}\nfunction calculateAutoRotation(properties) {\n  const {\n    x,\n    y,\n    x2,\n    y2\n  } = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {\n    width,\n    height,\n    padding\n  } = sizes;\n  const {\n    xAdjust,\n    yAdjust\n  } = label;\n  const p1 = {\n    x: properties.x,\n    y: properties.y\n  };\n  const p2 = {\n    x: properties.x2,\n    y: properties.y2\n  };\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {\n    labelSize: size,\n    padding\n  }, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {\n    size: size.w,\n    min: chartArea.left,\n    max: chartArea.right,\n    padding: padding.left\n  };\n  const yCoordinateSizes = {\n    size: size.h,\n    min: chartArea.top,\n    max: chartArea.bottom,\n    padding: padding.top\n  };\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - width / 2,\n    y: centerY - height / 2,\n    x2: centerX + width / 2,\n    y2: centerY + height / 2,\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({\n      w: properties.x2 - properties.x,\n      h: properties.y2 - properties.y\n    }, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({\n      w: properties.x - properties.x2,\n      h: properties.y - properties.y2\n    }, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {\n    labelSize,\n    padding\n  } = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = lineW > 0 && (labelSize.w / 2 + padding.left - space.x) / lineW;\n  const y = lineH > 0 && (labelSize.h / 2 + padding.top - space.y) / lineH;\n  return clamp(Math.max(x, y), 0, 0.25);\n}\nfunction spaceAround(properties, chartArea) {\n  const {\n    x,\n    x2,\n    y,\n    y2\n  } = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {\n    size,\n    min,\n    max,\n    padding\n  } = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= coordinate - padding - halfSize) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= coordinate + padding + halfSize) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {\n    length,\n    width\n  } = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {\n    x: length,\n    y: width + adjust\n  };\n  const p2 = {\n    x: 0,\n    y: adjust\n  };\n  return Math.abs(interpolateX(0, p1, p2));\n}\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {\n    length,\n    width,\n    fill,\n    backgroundColor,\n    borderColor\n  } = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\nclass EllipseAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({\n        x: mouseX,\n        y: mouseY\n      }, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\n    }\n    const {\n      x,\n      y,\n      x2,\n      y2\n    } = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2\n    } : {\n      start: x,\n      end: x2\n    };\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      width,\n      height,\n      centerX,\n      centerY,\n      options\n    } = this;\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  get label() {\n    return this.elements && this.elements[0];\n  }\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\nEllipseAnnotation.id = 'ellipseAnnotation';\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  const {\n    width,\n    height,\n    centerX,\n    centerY\n  } = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const hBorderWidth = borderWidth / 2 || 0;\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return a / Math.pow(xRadius + hBorderWidth, 2) + b / Math.pow(yRadius + hBorderWidth, 2) <= 1.0001;\n}\nclass PointAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {\n      x,\n      y,\n      x2,\n      y2,\n      width\n    } = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({\n        x: mouseX,\n        y: mouseY\n      }, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\n    }\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {\n      start: y,\n      end: y2,\n      value: mouseY\n    } : {\n      start: x,\n      end: x2,\n      value: mouseX\n    };\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    options.borderWidth = 0;\n    drawPoint(ctx, options, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n  resolveElementProperties(chart, options) {\n    return resolvePointProperties(chart, options);\n  }\n}\nPointAnnotation.id = 'pointAnnotation';\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nclass PolygonAnnotation extends Element {\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({\n      x: mouseX,\n      y: mouseY\n    }, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map(point => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n  draw(ctx) {\n    const {\n      elements,\n      options\n    } = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {\n      x,\n      y\n    } = properties;\n    const {\n      sides,\n      rotation\n    } = options;\n    const elements = [];\n    const angle = 2 * PI / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      elements.push(buildPointElement(properties, options, rad));\n    }\n    properties.elements = elements;\n    properties.initProperties = {\n      x,\n      y\n    };\n    return properties;\n  }\n}\nPolygonAnnotation.id = 'polygonAnnotation';\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\nfunction buildPointElement({\n  centerX,\n  centerY\n}, {\n  radius,\n  borderWidth\n}, rad) {\n  const halfBorder = borderWidth / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {\n    x: centerX + sin * radius,\n    y: centerY - cos * radius\n  };\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + halfBorder),\n      bY: centerY - cos * (radius + halfBorder)\n    }\n  };\n}\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if (B.bY > y !== A.bY > y && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\nconst annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\nconst directUpdater = {\n  update: Object.assign\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n    properties.skip = toSkip(properties);\n    if ('elements' in properties) {\n      updateSubElements(element, properties, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n    properties.options = resolveAnnotationOptions(resolver);\n    animations.update(element, properties);\n  }\n}\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\nfunction updateSubElements(mainElement, {\n  elements,\n  initProperties\n}, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    if (isObject(initProperties)) {\n      Object.assign(element, initProperties);\n    }\n  }\n  return element;\n}\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result, resolveObj(resolver, elementClass.defaults), resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    result[prop] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\nvar version = \"2.1.2\";\nconst chartStates = new Map();\nvar annotation = {\n  id: 'annotation',\n  version,\n  beforeRegister() {\n    requireVersion('chart.js', '3.7', Chart.version);\n  },\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hovered: []\n    });\n  },\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations, chart.scales);\n  },\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n  },\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      }\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      label: {}\n    }\n  },\n  descriptors: {\n    _indexable: false,\n    _scriptable: prop => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _fallback: true\n      }\n    }\n  },\n  additionalOptionScopes: ['']\n};\nfunction draw(chart, caller, clip) {\n  const {\n    ctx,\n    chartArea\n  } = chart;\n  const {\n    visibleElements\n  } = chartStates.get(chart);\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n  const drawableElements = getDrawableElements(visibleElements, caller).sort((a, b) => a.options.z - b.options.z);\n  for (const element of drawableElements) {\n    element.draw(chart.ctx, chartArea);\n  }\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push(el);\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push(sub);\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\nexport { annotation as default };","map":{"version":3,"names":["Element","defaults","Animations","Chart","distanceBetweenPoints","defined","callback","isObject","valueOrDefault","toRadians","toFont","isArray","addRoundedRectPath","toTRBLCorners","isFinite","toPadding","toDegrees","PI","drawPoint","RAD_PER_DEG","clipArea","unclipArea","interaction","modes","point","state","event","filterElements","intersect","nearest","options","getNearestItem","x","axis","y","getElements","mode","inRangeByAxis","element","inRange","getPointByAxis","center","visibleElements","filter","minDistance","Number","POSITIVE_INFINITY","reduce","nearestItems","getCenterPoint","evenPoint","distance","push","sort","a","b","_index","slice","moveHooks","hooks","concat","updateListeners","chart","listened","moveListened","_getElements","forEach","hook","listeners","annotations","scope","click","handleEvent","type","handleMoveEvents","handleClickEvents","elements","previous","hovered","context","changed","dispatchMoveEvents","checkElements","indexOf","dispatchEvent","handler","$context","isOlderPart","act","req","length","EPSILON","clamp","from","to","Math","min","max","clampAll","obj","key","Object","keys","inPointRange","radius","borderWidth","hBorderWidth","pow","inBoxRange","x2","y2","inRangeX","inRangeY","getElementCenterPoint","useFinalPosition","centerX","centerY","getProps","requireVersion","pkg","ver","strict","parts","split","i","parseInt","Error","isPercentString","s","endsWith","toPercent","parseFloat","getRelativePosition","size","position","getSize","value","calculateTextAlignment","width","textAlign","toPosition","isBoundToPoint","xValue","yValue","widthCache","Map","isImageOrCanvas","content","toString","translate","ctx","rotation","rotate","setBorderStyle","lineCap","borderCapStyle","setLineDash","borderDash","lineDashOffset","borderDashOffset","lineJoin","borderJoinStyle","lineWidth","strokeStyle","borderColor","setShadowStyle","shadowColor","backgroundShadowColor","shadowBlur","shadowOffsetX","shadowOffsetY","measureLabelSize","height","font","strokeWidth","textStrokeWidth","lines","mapKey","join","string","_measureText","has","save","count","text","measureText","restore","lineHeight","set","get","drawBox","rect","stroke","fillStyle","backgroundColor","beginPath","w","h","borderRadius","closePath","fill","borderShadowColor","drawLabel","drawImage","labels","lh","textBaseline","setTextStrokeStyle","l","strokeText","color","fillText","miterLimit","textStrokeColor","scaleValue","scale","fallback","parse","getPixelForValue","retrieveScaleID","scales","scaleID","charAt","axes","values","id","getDimensionByScale","reverse","start","end","getChartPoint","chartArea","xScale","yScale","left","top","resolveBoxProperties","right","bottom","xDim","getChartDimensionByScale","xMin","xMax","yDim","yMin","yMax","resolvePointProperties","box","isNaN","xAdjust","yAdjust","getChartCircle","resolveBoxAndLabelProperties","properties","optionScope","resolveLabelElementProperties$1","initProperties","result","calculateX","labelSize","padding","calculatePosition$1","adjust","label","calculateY","boxOpts","labelOpts","padStart","padEnd","availableSize","callout","display","rotated","angle","cos","sin","cx","cy","adjustScaleRange","range","getScaleLimits","changeScaleLimit","handleTickRangeOptions","verifyScaleOptions","annotation","verifyScaleIDs","limit","suggestedLimit","scaleLimitDefined","scaleOptions","verifyProperties","console","warn","prop","scaleIDOption","limits","NEGATIVE_INFINITY","updateLimits","props","raw","BoxAnnotation","mouseX","mouseY","draw","resolveElementProperties","drawTime","undefined","family","style","weight","z","xScaleID","yScaleID","defaultRoutes","descriptors","_fallback","positions","LabelAnnotation","visible","_visible","drawCallout","getLabelSize","boxSize","measureRect","pointX","pointY","margin","side","calculatePosition","calloutPosition","resolveCalloutPosition","isPointInRange","separatorStart","separatorEnd","getCalloutSeparatorCoord","sideStart","sideEnd","getCalloutSideCoord","moveTo","lineTo","rotatedPoint","getCalloutSeparatorAdjust","getCalloutSideAdjust","includes","resolveCalloutAutoPosition","xPoints","yPoints","index","pointInLine","p1","p2","t","interpolateX","abs","interpolateY","sqr","v","rangeLimit","LineAnnotation","epsilon","intersects","isOnLabel","atan2","sqrt","startOpts","endOpts","startAdjust","endAdjust","getArrowHeads","drawArrowHead","area","NaN","endValue","isHorizontal","applyScaleValueToDimension","startProp","endProp","inside","isLineInArea","limitLineToArea","labelProperties","resolveLabelElementProperties","arrowHeadsDefaults","arrowHeads","assign","limitPointToArea","x1","y1","dx","dy","lenSq","xx","yy","dim","textSize","calculateLabelPosition","calculateAutoRotation","sizes","rotatedSize","calculateT","pt","xCoordinateSizes","yCoordinateSizes","adjustLabelCoordinate","space","spaceAround","calculateTAdjust","lineSize","lineW","lineH","r","coordinate","labelSizes","halfSize","line","arrowStartOpts","arrowEndOpts","getLineAdjust","arrowOpts","offset","arrowOffsetX","EllipseAnnotation","pointInEllipse","ellipse","p","xRadius","yRadius","cosAngle","sinAngle","PointAnnotation","pointStyle","PolygonAnnotation","pointIsInPolygon","axisPoints","map","bY","bX","first","el","sides","rad","buildPointElement","halfBorder","points","isInside","A","B","annotationTypes","polygon","describe","directUpdater","update","resolveType","updateElements","animations","resolveAnimations","resyncElements","annotationOptions","getOrCreateElement","resolver","setContext","getContext","skip","toSkip","updateSubElements","resolveAnnotationOptions","animOpts","mainElement","subElements","definition","subElement","subResolver","override","elementClass","resolveObj","defs","optDefs","create","add","splice","Array","version","chartStates","beforeRegister","afterRegister","register","afterUnregister","unregister","beforeInit","beforeUpdate","args","afterDataLimits","afterUpdate","beforeDatasetsDraw","_args","clip","afterDatasetsDraw","beforeDraw","afterDraw","beforeEvent","afterDestroy","delete","_getState","numbers","common","_indexable","_scriptable","_allKeys","opts","additionalOptionScopes","caller","drawableElements","getDrawableElements","sub","default"],"sources":["/home/injinia/eden-link/node_modules/chartjs-plugin-annotation/dist/chartjs-plugin-annotation.esm.js"],"sourcesContent":["/*!\n* chartjs-plugin-annotation v2.1.2\n* https://www.chartjs.org/chartjs-plugin-annotation/index\n * (c) 2023 chartjs-plugin-annotation Contributors\n * Released under the MIT License\n */\nimport { Element, defaults, Animations, Chart } from 'chart.js';\nimport { distanceBetweenPoints, defined, callback, isObject, valueOrDefault, toRadians, toFont, isArray, addRoundedRectPath, toTRBLCorners, isFinite, toPadding, toDegrees, PI, drawPoint, RAD_PER_DEG, clipArea, unclipArea } from 'chart.js/helpers';\n\n/**\n * @typedef { import(\"chart.js\").ChartEvent } ChartEvent\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst interaction = {\n  modes: {\n    /**\n     * Point mode returns all elements that hit test based on the event position\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    point(state, event) {\n      return filterElements(state, event, {intersect: true});\n    },\n\n    /**\n     * Nearest mode returns the element closest to the event position\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found (only 1 element)\n     */\n    nearest(state, event, options) {\n      return getNearestItem(state, event, options);\n    },\n    /**\n     * x mode returns the elements that hit-test at the current x coordinate\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    x(state, event, options) {\n      return filterElements(state, event, {intersect: options.intersect, axis: 'x'});\n    },\n\n    /**\n     * y mode returns the elements that hit-test at the current y coordinate\n     * @param {Object} state - the state of the plugin\n     * @param {ChartEvent} event - the event we are find things at\n     * @param {Object} options - interaction options to use\n     * @return {AnnotationElement[]} - elements that are found\n     */\n    y(state, event, options) {\n      return filterElements(state, event, {intersect: options.intersect, axis: 'y'});\n    }\n  }\n};\n\n/**\n * Returns all elements that hit test based on the event position\n * @param {Object} state - the state of the plugin\n * @param {ChartEvent} event - the event we are find things at\n * @param {Object} options - interaction options to use\n * @return {AnnotationElement[]} - elements that are found\n */\nfunction getElements(state, event, options) {\n  const mode = interaction.modes[options.mode] || interaction.modes.nearest;\n  return mode(state, event, options);\n}\n\nfunction inRangeByAxis(element, event, axis) {\n  if (axis !== 'x' && axis !== 'y') {\n    return element.inRange(event.x, event.y, 'x', true) || element.inRange(event.x, event.y, 'y', true);\n  }\n  return element.inRange(event.x, event.y, axis, true);\n}\n\nfunction getPointByAxis(event, center, axis) {\n  if (axis === 'x') {\n    return {x: event.x, y: center.y};\n  } else if (axis === 'y') {\n    return {x: center.x, y: event.y};\n  }\n  return center;\n}\n\nfunction filterElements(state, event, options) {\n  return state.visibleElements.filter((element) => options.intersect ? element.inRange(event.x, event.y) : inRangeByAxis(element, event, options.axis));\n}\n\nfunction getNearestItem(state, event, options) {\n  let minDistance = Number.POSITIVE_INFINITY;\n\n  return filterElements(state, event, options)\n    .reduce((nearestItems, element) => {\n      const center = element.getCenterPoint();\n      const evenPoint = getPointByAxis(event, center, options.axis);\n      const distance = distanceBetweenPoints(event, evenPoint);\n      if (distance < minDistance) {\n        nearestItems = [element];\n        minDistance = distance;\n      } else if (distance === minDistance) {\n        // Can have multiple items at the same distance in which case we sort by size\n        nearestItems.push(element);\n      }\n\n      return nearestItems;\n    }, [])\n    .sort((a, b) => a._index - b._index)\n    .slice(0, 1); // return only the top item;\n}\n\nconst moveHooks = ['enter', 'leave'];\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\nconst hooks = moveHooks.concat('click');\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n */\nfunction updateListeners(chart, state, options) {\n  state.listened = false;\n  state.moveListened = false;\n  state._getElements = getElements; // for testing\n\n  hooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.listened = true;\n      state.listeners[hook] = options[hook];\n    } else if (defined(state.listeners[hook])) {\n      delete state.listeners[hook];\n    }\n  });\n  moveHooks.forEach(hook => {\n    if (typeof options[hook] === 'function') {\n      state.moveListened = true;\n    }\n  });\n\n  if (!state.listened || !state.moveListened) {\n    state.annotations.forEach(scope => {\n      if (!state.listened && typeof scope.click === 'function') {\n        state.listened = true;\n      }\n      if (!state.moveListened) {\n        moveHooks.forEach(hook => {\n          if (typeof scope[hook] === 'function') {\n            state.listened = true;\n            state.moveListened = true;\n          }\n        });\n      }\n    });\n  }\n}\n\n/**\n * @param {Object} state\n * @param {ChartEvent} event\n * @param {AnnotationPluginOptions} options\n * @return {boolean|undefined}\n */\nfunction handleEvent(state, event, options) {\n  if (state.listened) {\n    switch (event.type) {\n    case 'mousemove':\n    case 'mouseout':\n      return handleMoveEvents(state, event, options);\n    case 'click':\n      return handleClickEvents(state, event, options);\n    }\n  }\n}\n\nfunction handleMoveEvents(state, event, options) {\n  if (!state.moveListened) {\n    return;\n  }\n\n  let elements;\n\n  if (event.type === 'mousemove') {\n    elements = getElements(state, event, options.interaction);\n  } else {\n    elements = [];\n  }\n\n  const previous = state.hovered;\n  state.hovered = elements;\n\n  const context = {state, event};\n  let changed = dispatchMoveEvents(context, 'leave', previous, elements);\n  return dispatchMoveEvents(context, 'enter', elements, previous) || changed;\n}\n\nfunction dispatchMoveEvents({state, event}, hook, elements, checkElements) {\n  let changed;\n  for (const element of elements) {\n    if (checkElements.indexOf(element) < 0) {\n      changed = dispatchEvent(element.options[hook] || state.listeners[hook], element, event) || changed;\n    }\n  }\n  return changed;\n}\n\nfunction handleClickEvents(state, event, options) {\n  const listeners = state.listeners;\n  const elements = getElements(state, event, options.interaction);\n  let changed;\n  for (const element of elements) {\n    changed = dispatchEvent(element.options.click || listeners.click, element, event) || changed;\n  }\n  return changed;\n}\n\nfunction dispatchEvent(handler, element, event) {\n  return callback(handler, [element.$context, event]) === true;\n}\n\nconst isOlderPart = (act, req) => req > act || (act.length > req.length && act.slice(0, req.length) === req);\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('chart.js').InteractionAxis } InteractionAxis\n * @typedef { import('../../types/element').AnnotationElement } AnnotationElement\n */\n\nconst EPSILON = 0.001;\nconst clamp = (x, from, to) => Math.min(to, Math.max(from, x));\n\n/**\n * @param {Object} obj\n * @param {number} from\n * @param {number} to\n * @returns {Object}\n */\nfunction clampAll(obj, from, to) {\n  for (const key of Object.keys(obj)) {\n    obj[key] = clamp(obj[key], from, to);\n  }\n  return obj;\n}\n\n/**\n * @param {Point} point\n * @param {Point} center\n * @param {number} radius\n * @param {number} borderWidth\n * @returns {boolean}\n */\nfunction inPointRange(point, center, radius, borderWidth) {\n  if (!point || !center || radius <= 0) {\n    return false;\n  }\n  const hBorderWidth = borderWidth / 2;\n  return (Math.pow(point.x - center.x, 2) + Math.pow(point.y - center.y, 2)) <= Math.pow(radius + hBorderWidth, 2);\n}\n\n/**\n * @param {Point} point\n * @param {{x: number, y: number, x2: number, y2: number}} rect\n * @param {InteractionAxis} axis\n * @param {number} borderWidth\n * @returns {boolean}\n */\nfunction inBoxRange(point, {x, y, x2, y2}, axis, borderWidth) {\n  const hBorderWidth = borderWidth / 2;\n  const inRangeX = point.x >= x - hBorderWidth - EPSILON && point.x <= x2 + hBorderWidth + EPSILON;\n  const inRangeY = point.y >= y - hBorderWidth - EPSILON && point.y <= y2 + hBorderWidth + EPSILON;\n  if (axis === 'x') {\n    return inRangeX;\n  } else if (axis === 'y') {\n    return inRangeY;\n  }\n  return inRangeX && inRangeY;\n}\n\n/**\n * @param {AnnotationElement} element\n * @param {boolean} useFinalPosition\n * @returns {Point}\n */\nfunction getElementCenterPoint(element, useFinalPosition) {\n  const {centerX, centerY} = element.getProps(['centerX', 'centerY'], useFinalPosition);\n  return {x: centerX, y: centerY};\n}\n\n/**\n * @param {string} pkg\n * @param {string} min\n * @param {string} ver\n * @param {boolean} [strict=true]\n * @returns {boolean}\n */\nfunction requireVersion(pkg, min, ver, strict = true) {\n  const parts = ver.split('.');\n  let i = 0;\n  for (const req of min.split('.')) {\n    const act = parts[i++];\n    if (parseInt(req, 10) < parseInt(act, 10)) {\n      break;\n    }\n    if (isOlderPart(act, req)) {\n      if (strict) {\n        throw new Error(`${pkg} v${ver} is not supported. v${min} or newer is required.`);\n      } else {\n        return false;\n      }\n    }\n  }\n  return true;\n}\n\nconst isPercentString = (s) => typeof s === 'string' && s.endsWith('%');\nconst toPercent = (s) => clamp(parseFloat(s) / 100, 0, 1);\n\n/**\n * @typedef { import('../../types/options').AnnotationPointCoordinates } AnnotationPointCoordinates\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n * @typedef { import('../../types/label').LabelPositionObject } LabelPositionObject\n */\n\n/**\n * @param {number} size\n * @param {number|string} position\n * @param {number} to\n * @returns {number}\n */\nfunction getRelativePosition(size, position) {\n  if (position === 'start') {\n    return 0;\n  }\n  if (position === 'end') {\n    return size;\n  }\n  if (isPercentString(position)) {\n    return toPercent(position) * size;\n  }\n  return size / 2;\n}\n\n/**\n * @param {number} size\n * @param {number|string} value\n * @param {number} to\n * @returns {number}\n */\nfunction getSize(size, value) {\n  if (typeof value === 'number') {\n    return value;\n  } else if (isPercentString(value)) {\n    return toPercent(value) * size;\n  }\n  return size;\n}\n\n/**\n * @param {{x: number, width: number}} size\n * @param {CoreLabelOptions} options\n * @returns {number}\n */\nfunction calculateTextAlignment(size, options) {\n  const {x, width} = size;\n  const textAlign = options.textAlign;\n  if (textAlign === 'center') {\n    return x + width / 2;\n  } else if (textAlign === 'end' || textAlign === 'right') {\n    return x + width;\n  }\n  return x;\n}\n\n/**\n * @param {LabelPositionObject|string} value\n * @returns {LabelPositionObject}\n */\nfunction toPosition(value) {\n  if (isObject(value)) {\n    return {\n      x: valueOrDefault(value.x, 'center'),\n      y: valueOrDefault(value.y, 'center'),\n    };\n  }\n  value = valueOrDefault(value, 'center');\n  return {\n    x: value,\n    y: value\n  };\n}\n\n/**\n * @param {AnnotationPointCoordinates} options\n * @returns {boolean}\n */\nfunction isBoundToPoint(options) {\n  return options && (defined(options.xValue) || defined(options.yValue));\n}\n\nconst widthCache = new Map();\n\n/**\n * @typedef { import('chart.js').Point } Point\n * @typedef { import('../../types/label').CoreLabelOptions } CoreLabelOptions\n */\n\n/**\n * Determine if content is an image or a canvas.\n * @param {*} content\n * @returns boolean|undefined\n * @todo move this function to chart.js helpers\n */\nfunction isImageOrCanvas(content) {\n  if (content && typeof content === 'object') {\n    const type = content.toString();\n    return (type === '[object HTMLImageElement]' || type === '[object HTMLCanvasElement]');\n  }\n}\n\n/**\n * Set the translation on the canvas if the rotation must be applied.\n * @param {CanvasRenderingContext2D} ctx - chart canvas context\n * @param {Point} point - the point of translation\n * @param {number} rotation - rotation (in degrees) to apply\n */\nfunction translate(ctx, {x, y}, rotation) {\n  if (rotation) {\n    ctx.translate(x, y);\n    ctx.rotate(toRadians(rotation));\n    ctx.translate(-x, -y);\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n * @returns {boolean|undefined}\n */\nfunction setBorderStyle(ctx, options) {\n  if (options && options.borderWidth) {\n    ctx.lineCap = options.borderCapStyle;\n    ctx.setLineDash(options.borderDash);\n    ctx.lineDashOffset = options.borderDashOffset;\n    ctx.lineJoin = options.borderJoinStyle;\n    ctx.lineWidth = options.borderWidth;\n    ctx.strokeStyle = options.borderColor;\n    return true;\n  }\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {Object} options\n */\nfunction setShadowStyle(ctx, options) {\n  ctx.shadowColor = options.backgroundShadowColor;\n  ctx.shadowBlur = options.shadowBlur;\n  ctx.shadowOffsetX = options.shadowOffsetX;\n  ctx.shadowOffsetY = options.shadowOffsetY;\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {CoreLabelOptions} options\n * @returns {{width: number, height: number}}\n */\nfunction measureLabelSize(ctx, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    return {\n      width: getSize(content.width, options.width),\n      height: getSize(content.height, options.height)\n    };\n  }\n  const font = toFont(options.font);\n  const strokeWidth = options.textStrokeWidth;\n  const lines = isArray(content) ? content : [content];\n  const mapKey = lines.join() + font.string + strokeWidth + (ctx._measureText ? '-spriting' : '');\n  if (!widthCache.has(mapKey)) {\n    ctx.save();\n    ctx.font = font.string;\n    const count = lines.length;\n    let width = 0;\n    for (let i = 0; i < count; i++) {\n      const text = lines[i];\n      width = Math.max(width, ctx.measureText(text).width + strokeWidth);\n    }\n    ctx.restore();\n    const height = count * font.lineHeight + strokeWidth;\n    widthCache.set(mapKey, {width, height});\n  }\n  return widthCache.get(mapKey);\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {Object} options\n */\nfunction drawBox(ctx, rect, options) {\n  const {x, y, width, height} = rect;\n  ctx.save();\n  setShadowStyle(ctx, options);\n  const stroke = setBorderStyle(ctx, options);\n  ctx.fillStyle = options.backgroundColor;\n  ctx.beginPath();\n  addRoundedRectPath(ctx, {\n    x, y, w: width, h: height,\n    radius: clampAll(toTRBLCorners(options.borderRadius), 0, Math.min(width, height) / 2)\n  });\n  ctx.closePath();\n  ctx.fill();\n  if (stroke) {\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n  }\n  ctx.restore();\n}\n\n/**\n * @param {CanvasRenderingContext2D} ctx\n * @param {{x: number, y: number, width: number, height: number}} rect\n * @param {CoreLabelOptions} options\n */\nfunction drawLabel(ctx, rect, options) {\n  const content = options.content;\n  if (isImageOrCanvas(content)) {\n    ctx.drawImage(content, rect.x, rect.y, rect.width, rect.height);\n    return;\n  }\n  const labels = isArray(content) ? content : [content];\n  const font = toFont(options.font);\n  const lh = font.lineHeight;\n  const x = calculateTextAlignment(rect, options);\n  const y = rect.y + (lh / 2) + options.textStrokeWidth / 2;\n  ctx.save();\n  ctx.font = font.string;\n  ctx.textBaseline = 'middle';\n  ctx.textAlign = options.textAlign;\n  if (setTextStrokeStyle(ctx, options)) {\n    labels.forEach((l, i) => ctx.strokeText(l, x, y + (i * lh)));\n  }\n  ctx.fillStyle = options.color;\n  labels.forEach((l, i) => ctx.fillText(l, x, y + (i * lh)));\n  ctx.restore();\n}\n\nfunction setTextStrokeStyle(ctx, options) {\n  if (options.textStrokeWidth > 0) {\n    // https://stackoverflow.com/questions/13627111/drawing-text-with-an-outer-stroke-with-html5s-canvas\n    ctx.lineJoin = 'round';\n    ctx.miterLimit = 2;\n    ctx.lineWidth = options.textStrokeWidth;\n    ctx.strokeStyle = options.textStrokeColor;\n    return true;\n  }\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import(\"chart.js\").Point } Point\n * @typedef { import('../../types/element').AnnotationBoxModel } AnnotationBoxModel\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n * @typedef { import('../../types/options').PointAnnotationOptions } PointAnnotationOptions\n * @typedef { import('../../types/options').PolygonAnnotationOptions } PolygonAnnotationOptions\n */\n\n/**\n * @param {Scale} scale\n * @param {number|string} value\n * @param {number} fallback\n * @returns {number}\n */\nfunction scaleValue(scale, value, fallback) {\n  value = typeof value === 'number' ? value : scale.parse(value);\n  return isFinite(value) ? scale.getPixelForValue(value) : fallback;\n}\n\n/**\n * Search the scale defined in chartjs by the axis related to the annotation options key.\n * @param {{ [key: string]: Scale }} scales\n * @param {CoreAnnotationOptions} options\n * @param {string} key\n * @returns {string}\n */\nfunction retrieveScaleID(scales, options, key) {\n  const scaleID = options[key];\n  if (scaleID || key === 'scaleID') {\n    return scaleID;\n  }\n  const axis = key.charAt(0);\n  const axes = Object.values(scales).filter((scale) => scale.axis && scale.axis === axis);\n  if (axes.length) {\n    return axes[0].id;\n  }\n  return axis;\n}\n\n/**\n * @param {Scale} scale\n * @param {{min: number, max: number, start: number, end: number}} options\n * @returns {{start: number, end: number}|undefined}\n */\nfunction getDimensionByScale(scale, options) {\n  if (scale) {\n    const reverse = scale.options.reverse;\n    const start = scaleValue(scale, options.min, reverse ? options.end : options.start);\n    const end = scaleValue(scale, options.max, reverse ? options.start : options.end);\n    return {\n      start,\n      end\n    };\n  }\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {Point}\n */\nfunction getChartPoint(chart, options) {\n  const {chartArea, scales} = chart;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n  let x = chartArea.width / 2;\n  let y = chartArea.height / 2;\n\n  if (xScale) {\n    x = scaleValue(xScale, options.xValue, xScale.left + xScale.width / 2);\n  }\n\n  if (yScale) {\n    y = scaleValue(yScale, options.yValue, yScale.top + yScale.height / 2);\n  }\n  return {x, y};\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxProperties(chart, options) {\n  const scales = chart.scales;\n  const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n  const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n\n  if (!xScale && !yScale) {\n    return {};\n  }\n\n  let {left: x, right: x2} = xScale || chart.chartArea;\n  let {top: y, bottom: y2} = yScale || chart.chartArea;\n  const xDim = getChartDimensionByScale(xScale, {min: options.xMin, max: options.xMax, start: x, end: x2});\n  x = xDim.start;\n  x2 = xDim.end;\n  const yDim = getChartDimensionByScale(yScale, {min: options.yMin, max: options.yMax, start: y2, end: y});\n  y = yDim.start;\n  y2 = yDim.end;\n\n  return {\n    x,\n    y,\n    x2,\n    y2,\n    width: x2 - x,\n    height: y2 - y,\n    centerX: x + (x2 - x) / 2,\n    centerY: y + (y2 - y) / 2\n  };\n}\n\n/**\n * @param {Chart} chart\n * @param {PointAnnotationOptions|PolygonAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolvePointProperties(chart, options) {\n  if (!isBoundToPoint(options)) {\n    const box = resolveBoxProperties(chart, options);\n    let radius = options.radius;\n    if (!radius || isNaN(radius)) {\n      radius = Math.min(box.width, box.height) / 2;\n      options.radius = radius;\n    }\n    const size = radius * 2;\n    return {\n      x: box.x + options.xAdjust,\n      y: box.y + options.yAdjust,\n      x2: box.x + size + options.xAdjust,\n      y2: box.y + size + options.yAdjust,\n      centerX: box.centerX + options.xAdjust,\n      centerY: box.centerY + options.yAdjust,\n      width: size,\n      height: size\n    };\n  }\n  return getChartCircle(chart, options);\n}\n\n/**\n * @param {Chart} chart\n * @param {CoreAnnotationOptions} options\n * @returns {AnnotationBoxModel}\n */\nfunction resolveBoxAndLabelProperties(chart, options) {\n  const properties = resolveBoxProperties(chart, options);\n  const {x, y} = properties;\n  properties.elements = [{\n    type: 'label',\n    optionScope: 'label',\n    properties: resolveLabelElementProperties$1(chart, properties, options)\n  }];\n  properties.initProperties = {x, y};\n  return properties;\n}\n\nfunction getChartCircle(chart, options) {\n  const point = getChartPoint(chart, options);\n  const size = options.radius * 2;\n  return {\n    x: point.x - options.radius + options.xAdjust,\n    y: point.y - options.radius + options.yAdjust,\n    x2: point.x + options.radius + options.xAdjust,\n    y2: point.y + options.radius + options.yAdjust,\n    centerX: point.x + options.xAdjust,\n    centerY: point.y + options.yAdjust,\n    width: size,\n    height: size\n  };\n}\n\nfunction getChartDimensionByScale(scale, options) {\n  const result = getDimensionByScale(scale, options) || options;\n  return {\n    start: Math.min(result.start, result.end),\n    end: Math.max(result.start, result.end)\n  };\n}\n\nfunction calculateX({properties, options}, labelSize, position, padding) {\n  const {x: start, x2: end, width: size} = properties;\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.x,\n    padding: {start: padding.left, end: padding.right},\n    adjust: options.label.xAdjust,\n    size: labelSize.width\n  });\n}\n\nfunction calculateY({properties, options}, labelSize, position, padding) {\n  const {y: start, y2: end, height: size} = properties;\n  return calculatePosition$1({start, end, size, borderWidth: options.borderWidth}, {\n    position: position.y,\n    padding: {start: padding.top, end: padding.bottom},\n    adjust: options.label.yAdjust,\n    size: labelSize.height\n  });\n}\n\nfunction calculatePosition$1(boxOpts, labelOpts) {\n  const {start, end, borderWidth} = boxOpts;\n  const {position, padding: {start: padStart, end: padEnd}, adjust} = labelOpts;\n  const availableSize = end - borderWidth - start - padStart - padEnd - labelOpts.size;\n  return start + borderWidth / 2 + adjust + getRelativePosition(availableSize, position);\n}\n\nfunction resolveLabelElementProperties$1(chart, properties, options) {\n  const label = options.label;\n  label.backgroundColor = 'transparent';\n  label.callout.display = false;\n  const position = toPosition(label.position);\n  const padding = toPadding(label.padding);\n  const labelSize = measureLabelSize(chart.ctx, label);\n  const x = calculateX({properties, options}, labelSize, position, padding);\n  const y = calculateY({properties, options}, labelSize, position, padding);\n  const width = labelSize.width + padding.width;\n  const height = labelSize.height + padding.height;\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2,\n    rotation: label.rotation\n  };\n}\n\n/**\n * @typedef {import('chart.js').Point} Point\n */\n\n/**\n * Rotate a `point` relative to `center` point by `angle`\n * @param {Point} point - the point to rotate\n * @param {Point} center - center point for rotation\n * @param {number} angle - angle for rotation, in radians\n * @returns {Point} rotated point\n */\nfunction rotated(point, center, angle) {\n  const cos = Math.cos(angle);\n  const sin = Math.sin(angle);\n  const cx = center.x;\n  const cy = center.y;\n\n  return {\n    x: cx + cos * (point.x - cx) - sin * (point.y - cy),\n    y: cy + sin * (point.x - cx) + cos * (point.y - cy)\n  };\n}\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").Scale } Scale\n * @typedef { import('../../types/options').CoreAnnotationOptions } CoreAnnotationOptions\n */\n\n/**\n * @param {Chart} chart\n * @param {Scale} scale\n * @param {CoreAnnotationOptions[]} annotations\n */\nfunction adjustScaleRange(chart, scale, annotations) {\n  const range = getScaleLimits(chart.scales, scale, annotations);\n  let changed = changeScaleLimit(scale, range, 'min', 'suggestedMin');\n  changed = changeScaleLimit(scale, range, 'max', 'suggestedMax') || changed;\n  if (changed && typeof scale.handleTickRangeOptions === 'function') {\n    scale.handleTickRangeOptions();\n  }\n}\n\n/**\n * @param {CoreAnnotationOptions[]} annotations\n * @param {{ [key: string]: Scale }} scales\n */\nfunction verifyScaleOptions(annotations, scales) {\n  for (const annotation of annotations) {\n    verifyScaleIDs(annotation, scales);\n  }\n}\n\nfunction changeScaleLimit(scale, range, limit, suggestedLimit) {\n  if (isFinite(range[limit]) && !scaleLimitDefined(scale.options, limit, suggestedLimit)) {\n    const changed = scale[limit] !== range[limit];\n    scale[limit] = range[limit];\n    return changed;\n  }\n}\n\nfunction scaleLimitDefined(scaleOptions, limit, suggestedLimit) {\n  return defined(scaleOptions[limit]) || defined(scaleOptions[suggestedLimit]);\n}\n\nfunction verifyScaleIDs(annotation, scales) {\n  for (const key of ['scaleID', 'xScaleID', 'yScaleID']) {\n    const scaleID = retrieveScaleID(scales, annotation, key);\n    if (scaleID && !scales[scaleID] && verifyProperties(annotation, key)) {\n      console.warn(`No scale found with id '${scaleID}' for annotation '${annotation.id}'`);\n    }\n  }\n}\n\nfunction verifyProperties(annotation, key) {\n  if (key === 'scaleID') {\n    return true;\n  }\n  const axis = key.charAt(0);\n  for (const prop of ['Min', 'Max', 'Value']) {\n    if (defined(annotation[axis + prop])) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction getScaleLimits(scales, scale, annotations) {\n  const axis = scale.axis;\n  const scaleID = scale.id;\n  const scaleIDOption = axis + 'ScaleID';\n  const limits = {\n    min: valueOrDefault(scale.min, Number.NEGATIVE_INFINITY),\n    max: valueOrDefault(scale.max, Number.POSITIVE_INFINITY)\n  };\n  for (const annotation of annotations) {\n    if (annotation.scaleID === scaleID) {\n      updateLimits(annotation, scale, ['value', 'endValue'], limits);\n    } else if (retrieveScaleID(scales, annotation, scaleIDOption) === scaleID) {\n      updateLimits(annotation, scale, [axis + 'Min', axis + 'Max', axis + 'Value'], limits);\n    }\n  }\n  return limits;\n}\n\nfunction updateLimits(annotation, scale, props, limits) {\n  for (const prop of props) {\n    const raw = annotation[prop];\n    if (defined(raw)) {\n      const value = scale.parse(raw);\n      limits.min = Math.min(limits.min, value);\n      limits.max = Math.max(limits.max, value);\n    }\n  }\n}\n\nclass BoxAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.options.rotation);\n    drawBox(ctx, this, this.options);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n}\n\nBoxAnnotation.id = 'boxAnnotation';\n\nBoxAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  label: {\n    backgroundColor: 'transparent',\n    borderWidth: 0,\n    callout: {\n      display: false\n    },\n    color: 'black',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: undefined,\n    textAlign: 'start',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nBoxAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nBoxAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nconst positions = ['left', 'bottom', 'top', 'right'];\n\nclass LabelAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y} = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.rotation));\n    return inBoxRange({x, y}, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis, this.options.borderWidth);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const visible = !defined(this._visible) || this._visible;\n    if (!options.display || !options.content || !visible) {\n      return;\n    }\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), this.rotation);\n    drawCallout(ctx, this);\n    drawBox(ctx, this, options);\n    drawLabel(ctx, getLabelSize(this), options);\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    let point;\n    if (!isBoundToPoint(options)) {\n      const {centerX, centerY} = resolveBoxProperties(chart, options);\n      point = {x: centerX, y: centerY};\n    } else {\n      point = getChartPoint(chart, options);\n    }\n    const padding = toPadding(options.padding);\n    const labelSize = measureLabelSize(chart.ctx, options);\n    const boxSize = measureRect(point, labelSize, options, padding);\n    return {\n      pointX: point.x,\n      pointY: point.y,\n      ...boxSize,\n      rotation: options.rotation\n    };\n  }\n}\n\nLabelAnnotation.id = 'labelAnnotation';\n\nLabelAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundColor: 'transparent',\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderRadius: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 0,\n  callout: {\n    borderCapStyle: 'butt',\n    borderColor: undefined,\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderWidth: 1,\n    display: false,\n    margin: 5,\n    position: 'auto',\n    side: 5,\n    start: '50%',\n  },\n  color: 'black',\n  content: null,\n  display: true,\n  font: {\n    family: undefined,\n    lineHeight: undefined,\n    size: undefined,\n    style: undefined,\n    weight: undefined\n  },\n  height: undefined,\n  padding: 6,\n  position: 'center',\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  textAlign: 'center',\n  textStrokeColor: undefined,\n  textStrokeWidth: 0,\n  width: undefined,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nLabelAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction measureRect(point, size, options, padding) {\n  const width = size.width + padding.width + options.borderWidth;\n  const height = size.height + padding.height + options.borderWidth;\n  const position = toPosition(options.position);\n  const x = calculatePosition(point.x, width, options.xAdjust, position.x);\n  const y = calculatePosition(point.y, height, options.yAdjust, position.y);\n\n  return {\n    x,\n    y,\n    x2: x + width,\n    y2: y + height,\n    width,\n    height,\n    centerX: x + width / 2,\n    centerY: y + height / 2\n  };\n}\n\nfunction calculatePosition(start, size, adjust = 0, position) {\n  return start - getRelativePosition(size, position) + adjust;\n}\n\nfunction drawCallout(ctx, element) {\n  const {pointX, pointY, options} = element;\n  const callout = options.callout;\n  const calloutPosition = callout && callout.display && resolveCalloutPosition(element, callout);\n  if (!calloutPosition || isPointInRange(element, callout, calloutPosition)) {\n    return;\n  }\n\n  ctx.save();\n  ctx.beginPath();\n  const stroke = setBorderStyle(ctx, callout);\n  if (!stroke) {\n    return ctx.restore();\n  }\n  const {separatorStart, separatorEnd} = getCalloutSeparatorCoord(element, calloutPosition);\n  const {sideStart, sideEnd} = getCalloutSideCoord(element, calloutPosition, separatorStart);\n  if (callout.margin > 0 || options.borderWidth === 0) {\n    ctx.moveTo(separatorStart.x, separatorStart.y);\n    ctx.lineTo(separatorEnd.x, separatorEnd.y);\n  }\n  ctx.moveTo(sideStart.x, sideStart.y);\n  ctx.lineTo(sideEnd.x, sideEnd.y);\n  const rotatedPoint = rotated({x: pointX, y: pointY}, element.getCenterPoint(), toRadians(-element.rotation));\n  ctx.lineTo(rotatedPoint.x, rotatedPoint.y);\n  ctx.stroke();\n  ctx.restore();\n}\n\nfunction getCalloutSeparatorCoord(element, position) {\n  const {x, y, x2, y2} = element;\n  const adjust = getCalloutSeparatorAdjust(element, position);\n  let separatorStart, separatorEnd;\n  if (position === 'left' || position === 'right') {\n    separatorStart = {x: x + adjust, y};\n    separatorEnd = {x: separatorStart.x, y: y2};\n  } else {\n    //  position 'top' or 'bottom'\n    separatorStart = {x, y: y + adjust};\n    separatorEnd = {x: x2, y: separatorStart.y};\n  }\n  return {separatorStart, separatorEnd};\n}\n\nfunction getCalloutSeparatorAdjust(element, position) {\n  const {width, height, options} = element;\n  const adjust = options.callout.margin + options.borderWidth / 2;\n  if (position === 'right') {\n    return width + adjust;\n  } else if (position === 'bottom') {\n    return height + adjust;\n  }\n  return -adjust;\n}\n\nfunction getCalloutSideCoord(element, position, separatorStart) {\n  const {y, width, height, options} = element;\n  const start = options.callout.start;\n  const side = getCalloutSideAdjust(position, options.callout);\n  let sideStart, sideEnd;\n  if (position === 'left' || position === 'right') {\n    sideStart = {x: separatorStart.x, y: y + getSize(height, start)};\n    sideEnd = {x: sideStart.x + side, y: sideStart.y};\n  } else {\n    //  position 'top' or 'bottom'\n    sideStart = {x: separatorStart.x + getSize(width, start), y: separatorStart.y};\n    sideEnd = {x: sideStart.x, y: sideStart.y + side};\n  }\n  return {sideStart, sideEnd};\n}\n\nfunction getCalloutSideAdjust(position, options) {\n  const side = options.side;\n  if (position === 'left' || position === 'top') {\n    return -side;\n  }\n  return side;\n}\n\nfunction resolveCalloutPosition(element, options) {\n  const position = options.position;\n  if (positions.includes(position)) {\n    return position;\n  }\n  return resolveCalloutAutoPosition(element, options);\n}\n\nfunction resolveCalloutAutoPosition(element, options) {\n  const {x, y, x2, y2, width, height, pointX, pointY, centerX, centerY, rotation} = element;\n  const center = {x: centerX, y: centerY};\n  const start = options.start;\n  const xAdjust = getSize(width, start);\n  const yAdjust = getSize(height, start);\n  const xPoints = [x, x + xAdjust, x + xAdjust, x2];\n  const yPoints = [y + yAdjust, y2, y, y2];\n  const result = [];\n  for (let index = 0; index < 4; index++) {\n    const rotatedPoint = rotated({x: xPoints[index], y: yPoints[index]}, center, toRadians(rotation));\n    result.push({\n      position: positions[index],\n      distance: distanceBetweenPoints(rotatedPoint, {x: pointX, y: pointY})\n    });\n  }\n  return result.sort((a, b) => a.distance - b.distance)[0].position;\n}\n\nfunction getLabelSize({x, y, width, height, options}) {\n  const hBorderWidth = options.borderWidth / 2;\n  const padding = toPadding(options.padding);\n  return {\n    x: x + padding.left + hBorderWidth,\n    y: y + padding.top + hBorderWidth,\n    width: width - padding.left - padding.right - options.borderWidth,\n    height: height - padding.top - padding.bottom - options.borderWidth\n  };\n}\n\nfunction isPointInRange(element, callout, position) {\n  const {pointX, pointY} = element;\n  const margin = callout.margin;\n  let x = pointX;\n  let y = pointY;\n  if (position === 'left') {\n    x += margin;\n  } else if (position === 'right') {\n    x -= margin;\n  } else if (position === 'top') {\n    y += margin;\n  } else if (position === 'bottom') {\n    y -= margin;\n  }\n  return element.inRange(x, y);\n}\n\nconst pointInLine = (p1, p2, t) => ({x: p1.x + t * (p2.x - p1.x), y: p1.y + t * (p2.y - p1.y)});\nconst interpolateX = (y, p1, p2) => pointInLine(p1, p2, Math.abs((y - p1.y) / (p2.y - p1.y))).x;\nconst interpolateY = (x, p1, p2) => pointInLine(p1, p2, Math.abs((x - p1.x) / (p2.x - p1.x))).y;\nconst sqr = v => v * v;\nconst rangeLimit = (mouseX, mouseY, {x, y, x2, y2}, axis) => axis === 'y' ? {start: Math.min(y, y2), end: Math.max(y, y2), value: mouseY} : {start: Math.min(x, x2), end: Math.max(x, x2), value: mouseX};\n\nclass LineAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const hBorderWidth = this.options.borderWidth / 2;\n    if (axis !== 'x' && axis !== 'y') {\n      const epsilon = sqr(hBorderWidth);\n      const point = {mouseX, mouseY};\n      return intersects(this, point, epsilon, useFinalPosition) || isOnLabel(this, point, useFinalPosition);\n    }\n    const limit = rangeLimit(mouseX, mouseY, this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition), axis);\n    return (limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth) || isOnLabel(this, {mouseX, mouseY}, useFinalPosition, axis);\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {x, y, x2, y2, options} = this;\n\n    ctx.save();\n    if (!setBorderStyle(ctx, options)) {\n      // no border width, then line is not drawn\n      return ctx.restore();\n    }\n    setShadowStyle(ctx, options);\n    const angle = Math.atan2(y2 - y, x2 - x);\n    const length = Math.sqrt(Math.pow(x2 - x, 2) + Math.pow(y2 - y, 2));\n    const {startOpts, endOpts, startAdjust, endAdjust} = getArrowHeads(this);\n\n    ctx.translate(x, y);\n    ctx.rotate(angle);\n    ctx.beginPath();\n    ctx.moveTo(0 + startAdjust, 0);\n    ctx.lineTo(length - endAdjust, 0);\n    ctx.shadowColor = options.borderShadowColor;\n    ctx.stroke();\n    drawArrowHead(ctx, 0, startAdjust, startOpts);\n    drawArrowHead(ctx, length, -endAdjust, endOpts);\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    const {scales, chartArea} = chart;\n    const scale = scales[options.scaleID];\n    const area = {x: chartArea.left, y: chartArea.top, x2: chartArea.right, y2: chartArea.bottom};\n    let min, max;\n\n    if (scale) {\n      min = scaleValue(scale, options.value, NaN);\n      max = scaleValue(scale, options.endValue, min);\n      if (scale.isHorizontal()) {\n        area.x = min;\n        area.x2 = max;\n      } else {\n        area.y = min;\n        area.y2 = max;\n      }\n    } else {\n      const xScale = scales[retrieveScaleID(scales, options, 'xScaleID')];\n      const yScale = scales[retrieveScaleID(scales, options, 'yScaleID')];\n\n      if (xScale) {\n        applyScaleValueToDimension(area, xScale, {min: options.xMin, max: options.xMax, start: xScale.left, end: xScale.right, startProp: 'x', endProp: 'x2'});\n      }\n\n      if (yScale) {\n        applyScaleValueToDimension(area, yScale, {min: options.yMin, max: options.yMax, start: yScale.bottom, end: yScale.top, startProp: 'y', endProp: 'y2'});\n      }\n    }\n    const {x, y, x2, y2} = area;\n    const inside = isLineInArea(area, chart.chartArea);\n    const properties = inside\n      ? limitLineToArea({x, y}, {x: x2, y: y2}, chart.chartArea)\n      : {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n    properties.centerX = (x2 + x) / 2;\n    properties.centerY = (y2 + y) / 2;\n    const labelProperties = resolveLabelElementProperties(chart, properties, options.label);\n    // additonal prop to manage zoom/pan\n    labelProperties._visible = inside;\n\n    properties.elements = [{\n      type: 'label',\n      optionScope: 'label',\n      properties: labelProperties\n    }];\n    return properties;\n  }\n}\n\nLineAnnotation.id = 'lineAnnotation';\n\nconst arrowHeadsDefaults = {\n  backgroundColor: undefined,\n  backgroundShadowColor: undefined,\n  borderColor: undefined,\n  borderDash: undefined,\n  borderDashOffset: undefined,\n  borderShadowColor: undefined,\n  borderWidth: undefined,\n  display: undefined,\n  fill: undefined,\n  length: undefined,\n  shadowBlur: undefined,\n  shadowOffsetX: undefined,\n  shadowOffsetY: undefined,\n  width: undefined\n};\n\nLineAnnotation.defaults = {\n  adjustScaleRange: true,\n  arrowHeads: {\n    display: false,\n    end: Object.assign({}, arrowHeadsDefaults),\n    fill: false,\n    length: 12,\n    start: Object.assign({}, arrowHeadsDefaults),\n    width: 6\n  },\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 2,\n  display: true,\n  endValue: undefined,\n  label: {\n    backgroundColor: 'rgba(0,0,0,0.8)',\n    backgroundShadowColor: 'transparent',\n    borderCapStyle: 'butt',\n    borderColor: 'black',\n    borderDash: [],\n    borderDashOffset: 0,\n    borderJoinStyle: 'miter',\n    borderRadius: 6,\n    borderShadowColor: 'transparent',\n    borderWidth: 0,\n    callout: Object.assign({}, LabelAnnotation.defaults.callout),\n    color: '#fff',\n    content: null,\n    display: false,\n    drawTime: undefined,\n    font: {\n      family: undefined,\n      lineHeight: undefined,\n      size: undefined,\n      style: undefined,\n      weight: 'bold'\n    },\n    height: undefined,\n    padding: 6,\n    position: 'center',\n    rotation: 0,\n    shadowBlur: 0,\n    shadowOffsetX: 0,\n    shadowOffsetY: 0,\n    textAlign: 'center',\n    textStrokeColor: undefined,\n    textStrokeWidth: 0,\n    width: undefined,\n    xAdjust: 0,\n    yAdjust: 0,\n    z: undefined\n  },\n  scaleID: undefined,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  value: undefined,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nLineAnnotation.descriptors = {\n  arrowHeads: {\n    start: {\n      _fallback: true\n    },\n    end: {\n      _fallback: true\n    },\n    _fallback: true\n  }\n};\n\nLineAnnotation.defaultRoutes = {\n  borderColor: 'color'\n};\n\nfunction isLineInArea({x, y, x2, y2}, {top, right, bottom, left}) {\n  return !(\n    (x < left && x2 < left) ||\n    (x > right && x2 > right) ||\n    (y < top && y2 < top) ||\n    (y > bottom && y2 > bottom)\n  );\n}\n\nfunction limitPointToArea({x, y}, p2, {top, right, bottom, left}) {\n  if (x < left) {\n    y = interpolateY(left, {x, y}, p2);\n    x = left;\n  }\n  if (x > right) {\n    y = interpolateY(right, {x, y}, p2);\n    x = right;\n  }\n  if (y < top) {\n    x = interpolateX(top, {x, y}, p2);\n    y = top;\n  }\n  if (y > bottom) {\n    x = interpolateX(bottom, {x, y}, p2);\n    y = bottom;\n  }\n  return {x, y};\n}\n\nfunction limitLineToArea(p1, p2, area) {\n  const {x, y} = limitPointToArea(p1, p2, area);\n  const {x: x2, y: y2} = limitPointToArea(p2, p1, area);\n  return {x, y, x2, y2, width: Math.abs(x2 - x), height: Math.abs(y2 - y)};\n}\n\nfunction intersects(element, {mouseX, mouseY}, epsilon = EPSILON, useFinalPosition) {\n  // Adapted from https://stackoverflow.com/a/6853926/25507\n  const {x: x1, y: y1, x2, y2} = element.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n  const dx = x2 - x1;\n  const dy = y2 - y1;\n  const lenSq = sqr(dx) + sqr(dy);\n  const t = lenSq === 0 ? -1 : ((mouseX - x1) * dx + (mouseY - y1) * dy) / lenSq;\n  let xx, yy;\n  if (t < 0) {\n    xx = x1;\n    yy = y1;\n  } else if (t > 1) {\n    xx = x2;\n    yy = y2;\n  } else {\n    xx = x1 + t * dx;\n    yy = y1 + t * dy;\n  }\n  return (sqr(mouseX - xx) + sqr(mouseY - yy)) <= epsilon;\n}\n\nfunction isOnLabel(element, {mouseX, mouseY}, useFinalPosition, axis) {\n  const label = element.label;\n  return label.options.display && label.inRange(mouseX, mouseY, axis, useFinalPosition);\n}\n\nfunction applyScaleValueToDimension(area, scale, options) {\n  const dim = getDimensionByScale(scale, options);\n  area[options.startProp] = dim.start;\n  area[options.endProp] = dim.end;\n}\n\nfunction resolveLabelElementProperties(chart, properties, options) {\n  const borderWidth = options.borderWidth;\n  const padding = toPadding(options.padding);\n  const textSize = measureLabelSize(chart.ctx, options);\n  const width = textSize.width + padding.width + borderWidth;\n  const height = textSize.height + padding.height + borderWidth;\n  return calculateLabelPosition(properties, options, {width, height, padding}, chart.chartArea);\n}\n\nfunction calculateAutoRotation(properties) {\n  const {x, y, x2, y2} = properties;\n  const rotation = Math.atan2(y2 - y, x2 - x);\n  // Flip the rotation if it goes > PI/2 or < -PI/2, so label stays upright\n  return rotation > PI / 2 ? rotation - PI : rotation < PI / -2 ? rotation + PI : rotation;\n}\n\nfunction calculateLabelPosition(properties, label, sizes, chartArea) {\n  const {width, height, padding} = sizes;\n  const {xAdjust, yAdjust} = label;\n  const p1 = {x: properties.x, y: properties.y};\n  const p2 = {x: properties.x2, y: properties.y2};\n  const rotation = label.rotation === 'auto' ? calculateAutoRotation(properties) : toRadians(label.rotation);\n  const size = rotatedSize(width, height, rotation);\n  const t = calculateT(properties, label, {labelSize: size, padding}, chartArea);\n  const pt = pointInLine(p1, p2, t);\n  const xCoordinateSizes = {size: size.w, min: chartArea.left, max: chartArea.right, padding: padding.left};\n  const yCoordinateSizes = {size: size.h, min: chartArea.top, max: chartArea.bottom, padding: padding.top};\n  const centerX = adjustLabelCoordinate(pt.x, xCoordinateSizes) + xAdjust;\n  const centerY = adjustLabelCoordinate(pt.y, yCoordinateSizes) + yAdjust;\n  return {\n    x: centerX - (width / 2),\n    y: centerY - (height / 2),\n    x2: centerX + (width / 2),\n    y2: centerY + (height / 2),\n    centerX,\n    centerY,\n    pointX: pt.x,\n    pointY: pt.y,\n    width,\n    height,\n    rotation: toDegrees(rotation)\n  };\n}\n\nfunction rotatedSize(width, height, rotation) {\n  const cos = Math.cos(rotation);\n  const sin = Math.sin(rotation);\n  return {\n    w: Math.abs(width * cos) + Math.abs(height * sin),\n    h: Math.abs(width * sin) + Math.abs(height * cos)\n  };\n}\n\nfunction calculateT(properties, label, sizes, chartArea) {\n  let t;\n  const space = spaceAround(properties, chartArea);\n  if (label.position === 'start') {\n    t = calculateTAdjust({w: properties.x2 - properties.x, h: properties.y2 - properties.y}, sizes, label, space);\n  } else if (label.position === 'end') {\n    t = 1 - calculateTAdjust({w: properties.x - properties.x2, h: properties.y - properties.y2}, sizes, label, space);\n  } else {\n    t = getRelativePosition(1, label.position);\n  }\n  return t;\n}\n\nfunction calculateTAdjust(lineSize, sizes, label, space) {\n  const {labelSize, padding} = sizes;\n  const lineW = lineSize.w * space.dx;\n  const lineH = lineSize.h * space.dy;\n  const x = (lineW > 0) && ((labelSize.w / 2 + padding.left - space.x) / lineW);\n  const y = (lineH > 0) && ((labelSize.h / 2 + padding.top - space.y) / lineH);\n  return clamp(Math.max(x, y), 0, 0.25);\n}\n\nfunction spaceAround(properties, chartArea) {\n  const {x, x2, y, y2} = properties;\n  const t = Math.min(y, y2) - chartArea.top;\n  const l = Math.min(x, x2) - chartArea.left;\n  const b = chartArea.bottom - Math.max(y, y2);\n  const r = chartArea.right - Math.max(x, x2);\n  return {\n    x: Math.min(l, r),\n    y: Math.min(t, b),\n    dx: l <= r ? 1 : -1,\n    dy: t <= b ? 1 : -1\n  };\n}\n\nfunction adjustLabelCoordinate(coordinate, labelSizes) {\n  const {size, min, max, padding} = labelSizes;\n  const halfSize = size / 2;\n  if (size > max - min) {\n    // if it does not fit, display as much as possible\n    return (max + min) / 2;\n  }\n  if (min >= (coordinate - padding - halfSize)) {\n    coordinate = min + padding + halfSize;\n  }\n  if (max <= (coordinate + padding + halfSize)) {\n    coordinate = max - padding - halfSize;\n  }\n  return coordinate;\n}\n\nfunction getArrowHeads(line) {\n  const options = line.options;\n  const arrowStartOpts = options.arrowHeads && options.arrowHeads.start;\n  const arrowEndOpts = options.arrowHeads && options.arrowHeads.end;\n  return {\n    startOpts: arrowStartOpts,\n    endOpts: arrowEndOpts,\n    startAdjust: getLineAdjust(line, arrowStartOpts),\n    endAdjust: getLineAdjust(line, arrowEndOpts)\n  };\n}\n\nfunction getLineAdjust(line, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return 0;\n  }\n  const {length, width} = arrowOpts;\n  const adjust = line.options.borderWidth / 2;\n  const p1 = {x: length, y: width + adjust};\n  const p2 = {x: 0, y: adjust};\n  return Math.abs(interpolateX(0, p1, p2));\n}\n\nfunction drawArrowHead(ctx, offset, adjust, arrowOpts) {\n  if (!arrowOpts || !arrowOpts.display) {\n    return;\n  }\n  const {length, width, fill, backgroundColor, borderColor} = arrowOpts;\n  const arrowOffsetX = Math.abs(offset - length) + adjust;\n  ctx.beginPath();\n  setShadowStyle(ctx, arrowOpts);\n  setBorderStyle(ctx, arrowOpts);\n  ctx.moveTo(arrowOffsetX, -width);\n  ctx.lineTo(offset + adjust, 0);\n  ctx.lineTo(arrowOffsetX, width);\n  if (fill === true) {\n    ctx.fillStyle = backgroundColor || borderColor;\n    ctx.closePath();\n    ctx.fill();\n    ctx.shadowColor = 'transparent';\n  } else {\n    ctx.shadowColor = arrowOpts.borderShadowColor;\n  }\n  ctx.stroke();\n}\n\nclass EllipseAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const rotation = this.options.rotation;\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return pointInEllipse({x: mouseX, y: mouseY}, this.getProps(['width', 'height', 'centerX', 'centerY'], useFinalPosition), rotation, borderWidth);\n    }\n    const {x, y, x2, y2} = this.getProps(['x', 'y', 'x2', 'y2'], useFinalPosition);\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {start: y, end: y2} : {start: x, end: x2};\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-rotation));\n    return rotatedPoint[axis] >= limit.start - hBorderWidth - EPSILON && rotatedPoint[axis] <= limit.end + hBorderWidth + EPSILON;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {width, height, centerX, centerY, options} = this;\n\n    ctx.save();\n    translate(ctx, this.getCenterPoint(), options.rotation);\n    setShadowStyle(ctx, this.options);\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    const stroke = setBorderStyle(ctx, options);\n    ctx.ellipse(centerX, centerY, height / 2, width / 2, PI / 2, 0, 2 * PI);\n    ctx.fill();\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  get label() {\n    return this.elements && this.elements[0];\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolveBoxAndLabelProperties(chart, options);\n  }\n\n}\n\nEllipseAnnotation.id = 'ellipseAnnotation';\n\nEllipseAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  label: Object.assign({}, BoxAnnotation.defaults.label),\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  z: 0\n};\n\nEllipseAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nEllipseAnnotation.descriptors = {\n  label: {\n    _fallback: true\n  }\n};\n\nfunction pointInEllipse(p, ellipse, rotation, borderWidth) {\n  const {width, height, centerX, centerY} = ellipse;\n  const xRadius = width / 2;\n  const yRadius = height / 2;\n\n  if (xRadius <= 0 || yRadius <= 0) {\n    return false;\n  }\n  // https://stackoverflow.com/questions/7946187/point-and-ellipse-rotated-position-test-algorithm\n  const angle = toRadians(rotation || 0);\n  const hBorderWidth = borderWidth / 2 || 0;\n  const cosAngle = Math.cos(angle);\n  const sinAngle = Math.sin(angle);\n  const a = Math.pow(cosAngle * (p.x - centerX) + sinAngle * (p.y - centerY), 2);\n  const b = Math.pow(sinAngle * (p.x - centerX) - cosAngle * (p.y - centerY), 2);\n  return (a / Math.pow(xRadius + hBorderWidth, 2)) + (b / Math.pow(yRadius + hBorderWidth, 2)) <= 1.0001;\n}\n\nclass PointAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    const {x, y, x2, y2, width} = this.getProps(['x', 'y', 'x2', 'y2', 'width'], useFinalPosition);\n    const borderWidth = this.options.borderWidth;\n    if (axis !== 'x' && axis !== 'y') {\n      return inPointRange({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), width / 2, borderWidth);\n    }\n    const hBorderWidth = borderWidth / 2;\n    const limit = axis === 'y' ? {start: y, end: y2, value: mouseY} : {start: x, end: x2, value: mouseX};\n    return limit.value >= limit.start - hBorderWidth && limit.value <= limit.end + hBorderWidth;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const options = this.options;\n    const borderWidth = options.borderWidth;\n    if (options.radius < 0.1) {\n      return;\n    }\n    ctx.save();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    options.borderWidth = 0;\n    drawPoint(ctx, options, this.centerX, this.centerY);\n    if (stroke && !isImageOrCanvas(options.pointStyle)) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n    options.borderWidth = borderWidth;\n  }\n\n  resolveElementProperties(chart, options) {\n    return resolvePointProperties(chart, options);\n  }\n}\n\nPointAnnotation.id = 'pointAnnotation';\n\nPointAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  pointStyle: 'circle',\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPointAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nclass PolygonAnnotation extends Element {\n\n  inRange(mouseX, mouseY, axis, useFinalPosition) {\n    if (axis !== 'x' && axis !== 'y') {\n      return this.options.radius >= 0.1 && this.elements.length > 1 && pointIsInPolygon(this.elements, mouseX, mouseY, useFinalPosition);\n    }\n    const rotatedPoint = rotated({x: mouseX, y: mouseY}, this.getCenterPoint(useFinalPosition), toRadians(-this.options.rotation));\n    const axisPoints = this.elements.map((point) => axis === 'y' ? point.bY : point.bX);\n    const start = Math.min(...axisPoints);\n    const end = Math.max(...axisPoints);\n    return rotatedPoint[axis] >= start && rotatedPoint[axis] <= end;\n  }\n\n  getCenterPoint(useFinalPosition) {\n    return getElementCenterPoint(this, useFinalPosition);\n  }\n\n  draw(ctx) {\n    const {elements, options} = this;\n    ctx.save();\n    ctx.beginPath();\n    ctx.fillStyle = options.backgroundColor;\n    setShadowStyle(ctx, options);\n    const stroke = setBorderStyle(ctx, options);\n    let first = true;\n    for (const el of elements) {\n      if (first) {\n        ctx.moveTo(el.x, el.y);\n        first = false;\n      } else {\n        ctx.lineTo(el.x, el.y);\n      }\n    }\n    ctx.closePath();\n    ctx.fill();\n    // If no border, don't draw it\n    if (stroke) {\n      ctx.shadowColor = options.borderShadowColor;\n      ctx.stroke();\n    }\n    ctx.restore();\n  }\n\n  resolveElementProperties(chart, options) {\n    const properties = resolvePointProperties(chart, options);\n    const {x, y} = properties;\n    const {sides, rotation} = options;\n    const elements = [];\n    const angle = (2 * PI) / sides;\n    let rad = rotation * RAD_PER_DEG;\n    for (let i = 0; i < sides; i++, rad += angle) {\n      elements.push(buildPointElement(properties, options, rad));\n    }\n    properties.elements = elements;\n    properties.initProperties = {x, y};\n    return properties;\n  }\n}\n\nPolygonAnnotation.id = 'polygonAnnotation';\n\nPolygonAnnotation.defaults = {\n  adjustScaleRange: true,\n  backgroundShadowColor: 'transparent',\n  borderCapStyle: 'butt',\n  borderDash: [],\n  borderDashOffset: 0,\n  borderJoinStyle: 'miter',\n  borderShadowColor: 'transparent',\n  borderWidth: 1,\n  display: true,\n  point: {\n    radius: 0\n  },\n  radius: 10,\n  rotation: 0,\n  shadowBlur: 0,\n  shadowOffsetX: 0,\n  shadowOffsetY: 0,\n  sides: 3,\n  xAdjust: 0,\n  xMax: undefined,\n  xMin: undefined,\n  xScaleID: undefined,\n  xValue: undefined,\n  yAdjust: 0,\n  yMax: undefined,\n  yMin: undefined,\n  yScaleID: undefined,\n  yValue: undefined,\n  z: 0\n};\n\nPolygonAnnotation.defaultRoutes = {\n  borderColor: 'color',\n  backgroundColor: 'color'\n};\n\nfunction buildPointElement({centerX, centerY}, {radius, borderWidth}, rad) {\n  const halfBorder = borderWidth / 2;\n  const sin = Math.sin(rad);\n  const cos = Math.cos(rad);\n  const point = {x: centerX + sin * radius, y: centerY - cos * radius};\n  return {\n    type: 'point',\n    optionScope: 'point',\n    properties: {\n      x: point.x,\n      y: point.y,\n      centerX: point.x,\n      centerY: point.y,\n      bX: centerX + sin * (radius + halfBorder),\n      bY: centerY - cos * (radius + halfBorder)\n    }\n  };\n}\n\nfunction pointIsInPolygon(points, x, y, useFinalPosition) {\n  let isInside = false;\n  let A = points[points.length - 1].getProps(['bX', 'bY'], useFinalPosition);\n  for (const point of points) {\n    const B = point.getProps(['bX', 'bY'], useFinalPosition);\n    if ((B.bY > y) !== (A.bY > y) && x < (A.bX - B.bX) * (y - B.bY) / (A.bY - B.bY) + B.bX) {\n      isInside = !isInside;\n    }\n    A = B;\n  }\n  return isInside;\n}\n\nconst annotationTypes = {\n  box: BoxAnnotation,\n  ellipse: EllipseAnnotation,\n  label: LabelAnnotation,\n  line: LineAnnotation,\n  point: PointAnnotation,\n  polygon: PolygonAnnotation\n};\n\n/**\n * Register fallback for annotation elements\n * For example lineAnnotation options would be looked through:\n * - the annotation object (options.plugins.annotation.annotations[id])\n * - element options (options.elements.lineAnnotation)\n * - element defaults (defaults.elements.lineAnnotation)\n * - annotation plugin defaults (defaults.plugins.annotation, this is what we are registering here)\n */\nObject.keys(annotationTypes).forEach(key => {\n  defaults.describe(`elements.${annotationTypes[key].id}`, {\n    _fallback: 'plugins.annotation.common'\n  });\n});\n\nconst directUpdater = {\n  update: Object.assign\n};\n\n/**\n * @typedef { import(\"chart.js\").Chart } Chart\n * @typedef { import(\"chart.js\").UpdateMode } UpdateMode\n * @typedef { import('../../types/options').AnnotationPluginOptions } AnnotationPluginOptions\n */\n\n/**\n * Resolve the annotation type, checking if is supported.\n * @param {string} [type=line] - annotation type\n * @returns {string} resolved annotation type\n */\nfunction resolveType(type = 'line') {\n  if (annotationTypes[type]) {\n    return type;\n  }\n  console.warn(`Unknown annotation type: '${type}', defaulting to 'line'`);\n  return 'line';\n}\n\n/**\n * @param {Chart} chart\n * @param {Object} state\n * @param {AnnotationPluginOptions} options\n * @param {UpdateMode} mode\n */\nfunction updateElements(chart, state, options, mode) {\n  const animations = resolveAnimations(chart, options.animations, mode);\n\n  const annotations = state.annotations;\n  const elements = resyncElements(state.elements, annotations);\n\n  for (let i = 0; i < annotations.length; i++) {\n    const annotationOptions = annotations[i];\n    const element = getOrCreateElement(elements, i, annotationOptions.type);\n    const resolver = annotationOptions.setContext(getContext(chart, element, annotationOptions));\n    const properties = element.resolveElementProperties(chart, resolver);\n\n    properties.skip = toSkip(properties);\n\n    if ('elements' in properties) {\n      updateSubElements(element, properties, resolver, animations);\n      // Remove the sub-element definitions from properties, so the actual elements\n      // are not overwritten by their definitions\n      delete properties.elements;\n    }\n\n    if (!defined(element.x)) {\n      // If the element is newly created, assing the properties directly - to\n      // make them readily awailable to any scriptable options. If we do not do this,\n      // the properties retruned by `resolveElementProperties` are available only\n      // after options resolution.\n      Object.assign(element, properties);\n    }\n\n    properties.options = resolveAnnotationOptions(resolver);\n\n    animations.update(element, properties);\n  }\n}\n\nfunction toSkip(properties) {\n  return isNaN(properties.x) || isNaN(properties.y);\n}\n\nfunction resolveAnimations(chart, animOpts, mode) {\n  if (mode === 'reset' || mode === 'none' || mode === 'resize') {\n    return directUpdater;\n  }\n  return new Animations(chart, animOpts);\n}\n\nfunction updateSubElements(mainElement, {elements, initProperties}, resolver, animations) {\n  const subElements = mainElement.elements || (mainElement.elements = []);\n  subElements.length = elements.length;\n  for (let i = 0; i < elements.length; i++) {\n    const definition = elements[i];\n    const properties = definition.properties;\n    const subElement = getOrCreateElement(subElements, i, definition.type, initProperties);\n    const subResolver = resolver[definition.optionScope].override(definition);\n    properties.options = resolveAnnotationOptions(subResolver);\n    animations.update(subElement, properties);\n  }\n}\n\nfunction getOrCreateElement(elements, index, type, initProperties) {\n  const elementClass = annotationTypes[resolveType(type)];\n  let element = elements[index];\n  if (!element || !(element instanceof elementClass)) {\n    element = elements[index] = new elementClass();\n    if (isObject(initProperties)) {\n      Object.assign(element, initProperties);\n    }\n  }\n  return element;\n}\n\nfunction resolveAnnotationOptions(resolver) {\n  const elementClass = annotationTypes[resolveType(resolver.type)];\n  const result = {};\n  result.id = resolver.id;\n  result.type = resolver.type;\n  result.drawTime = resolver.drawTime;\n  Object.assign(result,\n    resolveObj(resolver, elementClass.defaults),\n    resolveObj(resolver, elementClass.defaultRoutes));\n  for (const hook of hooks) {\n    result[hook] = resolver[hook];\n  }\n  return result;\n}\n\nfunction resolveObj(resolver, defs) {\n  const result = {};\n  for (const prop of Object.keys(defs)) {\n    const optDefs = defs[prop];\n    const value = resolver[prop];\n    result[prop] = isObject(optDefs) ? resolveObj(value, optDefs) : value;\n  }\n  return result;\n}\n\nfunction getContext(chart, element, annotation) {\n  return element.$context || (element.$context = Object.assign(Object.create(chart.getContext()), {\n    element,\n    id: annotation.id,\n    type: 'annotation'\n  }));\n}\n\nfunction resyncElements(elements, annotations) {\n  const count = annotations.length;\n  const start = elements.length;\n\n  if (start < count) {\n    const add = count - start;\n    elements.splice(start, 0, ...new Array(add));\n  } else if (start > count) {\n    elements.splice(count, start - count);\n  }\n  return elements;\n}\n\nvar version = \"2.1.2\";\n\nconst chartStates = new Map();\n\nvar annotation = {\n  id: 'annotation',\n\n  version,\n\n  beforeRegister() {\n    requireVersion('chart.js', '3.7', Chart.version);\n  },\n\n  afterRegister() {\n    Chart.register(annotationTypes);\n  },\n\n  afterUnregister() {\n    Chart.unregister(annotationTypes);\n  },\n\n  beforeInit(chart) {\n    chartStates.set(chart, {\n      annotations: [],\n      elements: [],\n      visibleElements: [],\n      listeners: {},\n      listened: false,\n      moveListened: false,\n      hovered: []\n    });\n  },\n\n  beforeUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    const annotations = state.annotations = [];\n\n    let annotationOptions = options.annotations;\n    if (isObject(annotationOptions)) {\n      Object.keys(annotationOptions).forEach(key => {\n        const value = annotationOptions[key];\n        if (isObject(value)) {\n          value.id = key;\n          annotations.push(value);\n        }\n      });\n    } else if (isArray(annotationOptions)) {\n      annotations.push(...annotationOptions);\n    }\n    verifyScaleOptions(annotations, chart.scales);\n  },\n\n  afterDataLimits(chart, args) {\n    const state = chartStates.get(chart);\n    adjustScaleRange(chart, args.scale, state.annotations.filter(a => a.display && a.adjustScaleRange));\n  },\n\n  afterUpdate(chart, args, options) {\n    const state = chartStates.get(chart);\n    updateListeners(chart, state, options);\n    updateElements(chart, state, options, args.mode);\n    state.visibleElements = state.elements.filter(el => !el.skip && el.options.display);\n  },\n\n  beforeDatasetsDraw(chart, _args, options) {\n    draw(chart, 'beforeDatasetsDraw', options.clip);\n  },\n\n  afterDatasetsDraw(chart, _args, options) {\n    draw(chart, 'afterDatasetsDraw', options.clip);\n  },\n\n  beforeDraw(chart, _args, options) {\n    draw(chart, 'beforeDraw', options.clip);\n  },\n\n  afterDraw(chart, _args, options) {\n    draw(chart, 'afterDraw', options.clip);\n  },\n\n  beforeEvent(chart, args, options) {\n    const state = chartStates.get(chart);\n    if (handleEvent(state, args.event, options)) {\n      args.changed = true;\n    }\n  },\n\n  afterDestroy(chart) {\n    chartStates.delete(chart);\n  },\n\n  _getState(chart) {\n    return chartStates.get(chart);\n  },\n\n  defaults: {\n    animations: {\n      numbers: {\n        properties: ['x', 'y', 'x2', 'y2', 'width', 'height', 'centerX', 'centerY', 'pointX', 'pointY', 'radius'],\n        type: 'number'\n      },\n    },\n    clip: true,\n    interaction: {\n      mode: undefined,\n      axis: undefined,\n      intersect: undefined\n    },\n    common: {\n      drawTime: 'afterDatasetsDraw',\n      label: {\n      }\n    }\n  },\n\n  descriptors: {\n    _indexable: false,\n    _scriptable: (prop) => !hooks.includes(prop),\n    annotations: {\n      _allKeys: false,\n      _fallback: (prop, opts) => `elements.${annotationTypes[resolveType(opts.type)].id}`\n    },\n    interaction: {\n      _fallback: true\n    },\n    common: {\n      label: {\n        _fallback: true\n      }\n    }\n  },\n\n  additionalOptionScopes: ['']\n};\n\nfunction draw(chart, caller, clip) {\n  const {ctx, chartArea} = chart;\n  const {visibleElements} = chartStates.get(chart);\n\n  if (clip) {\n    clipArea(ctx, chartArea);\n  }\n\n  const drawableElements = getDrawableElements(visibleElements, caller).sort((a, b) => a.options.z - b.options.z);\n\n  for (const element of drawableElements) {\n    element.draw(chart.ctx, chartArea);\n  }\n\n  if (clip) {\n    unclipArea(ctx);\n  }\n}\n\nfunction getDrawableElements(elements, caller) {\n  const drawableElements = [];\n  for (const el of elements) {\n    if (el.options.drawTime === caller) {\n      drawableElements.push(el);\n    }\n    if (el.elements && el.elements.length) {\n      for (const sub of el.elements) {\n        if (sub.options.display && sub.options.drawTime === caller) {\n          drawableElements.push(sub);\n        }\n      }\n    }\n  }\n  return drawableElements;\n}\n\nexport { annotation as default };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}